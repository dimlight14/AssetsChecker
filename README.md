# AssetsChecker
![image](https://github.com/dimlight14/AssetsChecker/assets/17859007/202076e1-8f6c-4a6d-a338-ee1f659907ae)


### Устройство работы.

Окно инструмента вызывается через _Tools=>Find Missing References_.

Раздел _Settings_ определяет какие папки и файлы будут исключены из поиска (Scripts, Packages, Scenes).

_Path Filter_ фильтрует результаты, показывая только ассеты, у которых в пути содержится введенное в фильтр слово.

Таблица ассетов:
* _#_  - номер ассета в списке
* _Asset path_  - путь до ассета в проекте. Нажатие на эту кнопку открывает местоположение ассета в Project tab.
* _Asset type_ - тип ассета. Все ошибки внутри одного префаба или сцены отображаются одной записью.
* _Marked Resolved_ - галочка для отображения ассетов, в которых пользователь избавился от ошибок. Не делает ничего, кроме изменения вида записи. Выставляется вручную по желанию. Добавлено для удобства навигации.
* _Mis. Ref. Count_ - количество ошибок внутри ассета (missing references + missing scripts + missing prefabs)
* _Field names or GameObject/Component/Name_ - имя поля с ошибкой или путь на сцене до объекта с ошибкой. Список, если есть несколько ошибок.


### Логика создания интсрумента.

Когда я создавал инструмент прежде всего передо мной был вопрос "Как понять что у ассета есть missing reference?". Missing reference должно быть полем - ссылкой, которое ссылается на id другого ассета, но этого ассета нет в проекте. После некоторого размышления (и короткого совещания с Google) я нашел 3 способа:
* Создать базу данных всех ассетов (id если быть точнее), после чего проверять все поля ассетов, ссылаются ли они на что-то в этой базе данных. Дополнительно, можно пытаться анализировать метаданные построчно, ища FileId, или создать SerializedObject. Использование SerializedObject выглядит намного проще.
* Брать поля ассетов и пытаться найти ассет на который ссылается это поле в проекте. (Например, брать guid через AssetDatabase.TryGetGUIDAndLocalFileIdentifier(), потом брать путь через AssetDatabase.GUIDToAssetPath())
* Проверять на null поле ассета (serializedProperty.objectReferenceValue). Если id объекта на который ссылается поле (serializedProperty.objectReferenceInstanceIDValue) не равно 0, но значение самого поле равно null - это missing reference.

Первый способ выглядит слишком громоздким и более медленным. Нам будет нужно пройтись два раза по массиву ассетов, первый раз для создания базы данных, второй - для собственно проверки. Скорость не является главным критерием для инструмента, и вполне вероятно этот способ не сильно отставал бы в производительности от других, но я не вижу преимуществ этого метода. Помимо того, такой подход ограничивал возможность анализа части ассетов проекта, поскольку нам всегда нужно завести все ассеты до единого в базу данных. Инструмент сейчас не особо настроен на частичный анализ, но его можно легко дописать, если понадобится необходимость.
Второй и третий способы очень похожи и показали почти идентичные результаты, хотя третий способ был чуть-чуть быстрее. Второй способ выглядит несколько надежнее, поскольку производит поэтапную проверку наличия ассета. Однако, в действительности, мне кажется, что надежность обоих методов зависит от работы внутренних механизмов Unity и от того как они поменяются в будущем. Иначе говоря, я пришел к выводу чтобы метода одинаково надежны, тем более что я не нашел ошибок при тестировании обоих методов. Третий способ чуточку проще, что означает более легкую поддержку инструмента, хотя разница и незначительна. В итоге я остановился на третьем методе.  

Следующим вопросом был "Как получить список всех ассетов?". Можно было брать все файлы по папкам (например, с помощью Directory.GetFiles) или использовать AssetDatabase.GetAllAssetPaths. Первый способ давал больше возможности настройки частичного анализа, второй гарантировал, что ассеты не ускользнут проверки. Я предпочел более надежный второй способ.
